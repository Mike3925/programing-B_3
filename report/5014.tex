\documentclass[a4paper,11pt, titlepage]{jsarticle}

% フォント
\usepackage[T1]{fontenc}
\usepackage{lmodern}

% 数式
\usepackage{amsmath,amsfonts, amssymb}
\usepackage{bm}
% 画像
\usepackage[dvipdfmx]{graphicx}
\usepackage{multirow} % 表で複数行にまたがる
\usepackage{subcaption} % 図を並べて配置
\usepackage{float} % 強制的に図の位置を指定する
\usepackage{tikz}
\usetikzlibrary{positioning, arrows.meta}
\usepackage{longtable}

% 引用
\usepackage{url,natbib}

% 箇条書き
\usepackage{enumitem}

% ソースコード配置
\usepackage{listings}
\usepackage{plistings}



\begin{document}

\title{プログラミングBレポート\\課題3}
\date{\today}
\author{担当教員: 武政 淳二\\ \\大坪　祐清\\学籍番号: 09B25014}
\maketitle

\section{課題内容}
基本課題および発展課題に取り組んだ.

% \begin{quote}
  
%   以下に挙げる 2 種類の検索を実現するプログラムを作成し，レポートにまとめよ．
  
%   \begin{enumerate}[label=(検索\arabic*)]
%   \item 郵便番号を入力すると，対応する住所を出力する．
%   \item 住所名の一部を表す文字列を入力すると，その文字列を含む一連の住所およびそれらに対応する郵便番号のリストを出力する．
%   ただし，リストは郵便番号で昇順にソートすること．
%   \end{enumerate}
  
%   ただし，プログラムは以下の 2 段階の処理を実行すること．
%   \begin{enumerate}
%     \item 前処理  
  
%     検索を容易にするための前処理を担当する．郵便番号と住所を含むテキストファイルを入力として，構造体を利用してメモリに格納する．
%     \item 検索処理
    
%   （検索 1）もしくは（検索 2）を処理し,検索結果を画面に出力する.
%   \end{enumerate}
  
%   なお,入力のテキストファイルは,以下の,日本郵政株式会社のWeb ページ\footnote{\url{http://www.post.japanpost.jp/zipcode/dl/kogaki/zip/ken_all.zip}}からダウンロードしたcsvファイルとする.
  
%   csvファイルの各列の意味は,表\ref{fig:csv_meaning}で示す.ただし,本課題で扱わない10列目以降は省略した.
  
%   \begin{table}[htbp]
%     \centering
%     \caption{csvファイルの各列の意味(9列目まで)}
%     \label{fig:csv_meaning}
%     \begin{tabular}{|c|l|} \hline
%       1列目 & 全国地方公共団体コード(JIS X0401、X0402) \\ \hline
%       2列目 & 旧郵便番号(5桁) \\ \hline
%       3列目 & 郵便番号(7桁) \\ \hline
%       4列目 &  都道府県名(半角カタカナ)\\ \hline
%       5列目 &  市区町村名(半角カタカナ)\\ \hline
%       6列目 &  町域名(半角カタカナ)\\ \hline
%       7列目 &  都道府県名(漢字)\\ \hline
%       8列目 &  市区町村名(漢字)\\ \hline
%       9列目 &  町域名(漢字)\\ \hline
%     \end{tabular}
%   \end{table}
% \end{quote}

\section{アルゴリズムの説明}
\label{sec:explain-algo}
以下の手順で,処理を進める.
\begin{enumerate}
  \item CSVファイルの1行目からファイルの終わりまで以下の処理を繰り返す.
  \label{get_csv}
  \begin{enumerate}
    \item CSVファイルを読み込み,3行目,7行目,8行目,9行目を変数に読み込む.
    \item 読み込んだ変数を,構造体配列に読み込む. 
  \end{enumerate}
  \item (検索1)と(検索2)のどちらの検索をしたいのか,あるいはプログラムを終了したいのか,ユーザー/入力ファイルからの入力を受け付ける. \label{req-input}
  \label{prg_s}
  \item (検索1)あるいは(検索2)をユーザー/入力ファイルが望んだ場合,検索したい郵便番号ないしは住所の入力を受けつけ,変数として受け取る. \label{get_input}
  \item 入力に応じて条件分岐を行う \label{conditional_branch}
  \item (検索1)の場合の処理
  \begin{enumerate}
    \item クイックソートを用いて,郵便番号が昇順になるように構造体配列をソートする. \label{1-sort}
    \item ユーザーからの郵便番号の入力と,ソートされた構造体配列をもとに,二分探索法で目的の住所を探す. \label{1-binary}
    \item 条件にあったデータがあったら,郵便番号と住所を出力する. \label{1-output}
  \end{enumerate}
  \item (検索2)の場合の処理
  \label{prg_e}
  \begin{enumerate}
    \item n=1からn=「CSVファイルで読み込んだ行数」まで,以下の処理を繰り返す
    \begin{enumerate}
      \item n行目の都道府県名,市区町村名,町域名のいずれかにクエリが含まれていたら,配列にnを追加する. \label{2-pref-city-town}
      \label{search_2_first_input}
      \item \ref{search_2_first_input}の操作でいずれにも,クエリが含まれていなかったかつ,n行目の住所にクエリが含まれていたら,配列にnを追加する. \label{2-adr-all}
    \end{enumerate}
    \item 配列をクイックソートで,郵便番号が昇順になるようにソートする. \label{2-sort}
    \item 配列に入っている情報をもとに,郵便番号と住所を出力する. \label{2-output}
    \item ユーザー/入力ファイルに,絞り込み検索をしたいか尋ねる. \label{2-ask-to-refine}
    \item 絞り込み検索をする場合,絞り込みたい住所の入力を受けつけ,変数として受け取る. 
    \label{re_search_2s}
    \item n=1からn=「\ref{search_2_first_input}の配列に追加した数」まで,以下の処理を繰り返す.  
    \begin{enumerate}
      \item \ref{search_2_first_input}の配列のn番目の要素の行の都道府県名,市区町村名,町域名のいずれかに入力の文字列が含まれていたら,\ref{search_2_first_input}の配列とは別の配列にnを追加する.
      \label{re_search_first}
      \item 前述のいずれにも,クエリが含まれていなかったかつ,\ref{search_2_first_input}の配列のn番目の要素の行の住所にクエリが含まれていたら,\ref{re_search_first}の配列にnを追加する. \label{re_search_second}
    \end{enumerate}
    \item \ref{re_search_first}の配列に入っている情報をもとに,郵便番号と住所を出力する. \label{re_output}
    \item ユーザー/入力ファイルに絞り込み検索をさらに,したいか尋ねる.
    \label{re_search_2e}
    \item 絞り込み検索をしたい場合,\ref{re_search_2s} $\sim$ \ref{re_search_2e}の操作を同様に繰り返す. \label{re_re_refine}
  \end{enumerate}
  \item いずれかの操作が終わったら,再び,\ref{prg_s} $\sim$ \ref{prg_e}の操作を繰り返す. \label{re_do}
\end{enumerate}

\section{プログラムの説明}
本プログラムは,C言語にて記述した.
\subsection{入力形式}
プログラムへの入力は,モードによって,異なる.

プログラムに引数を与えずに,実行する場合,インタラクティブモードとなる.この場合,プログラムは実行中に,検索モードと検索クエリを標準入力から受け取り,検索を行う.

プログラム実行時に,検索モードと検索クエリの列を記入した入力ファイル名を
引数として指定し,実行する場合,ファイルモードとなる.この場合,プログラムは検索モードと検索クエリをファイルから読み取り,検索する.

\subsection{出力形式}
プログラムの出力は,検索の結果,得られた住所である.
出力は,[郵便番号]:[住所]の形式で出力し,結果が複数ある場合は,郵便番号順が昇順になるように出力する.

\subsection{データ構造}
本プログラムのデータ構造を,表\ref{fig:data_struct}に示す.

\begin{table}[htbp]
   \centering
   \caption{プログラムのデータ構造}
   \label{fig:data_struct}
   \begin{tabular}{|c|l|l|} \hline
      データ型 & 型名 & 概要\\ \hline
      構造型 & ADDRESS  & 
      \begin{tabular}{l}
        CSVの1行分のデータを記憶する. \\
        要素は表\ref{fig:ADDRESS_element}に示す
      \end{tabular}
      \\ \hline
   \end{tabular} 
\end{table}

\begin{table}[htbp]
   \centering
   \caption{ADDRESS型の要素}
   \label{fig:ADDRESS_element}
   \begin{tabular}{|c|l|l|} \hline
      要素の型 & 変数名 & 概要\\ \hline
      int & code & 郵便番号を記憶する \\ \hline
      char型配列 & pref[20] & 住所の都道府県名を記憶する. \\ \hline
      char型配列 & city[32] & 住所の市区町村名を記憶する. \\ \hline
      char型配列 & town[116] & 住所の町域名を記憶する. \\ \hline
   \end{tabular}
\end{table}

\subsection{大域変数}
本プログラムの大域変数を,表\ref{fig:global_variation}に示す.

\begin{table}[htbp]
   \centering
   \caption{プログラムの大域変数}
   \label{fig:global_variation}
   \begin{tabular}{|c|l|l|} \hline
      型名 & 変数名 & 概要 \\ \hline
      ADDRESS & address\_data[200000] & 
      \begin{tabular}{l}
        CSVの全行のデータを\\
        ADDRESS型配列として記憶する.
      \end{tabular}
      \\ \hline
      int & mode & 検索モードを記憶する. \\ \hline
      int & refine\_flag & 絞り込み検索をするかどうか記憶する. \\ \hline
      char & query[200] & 検索クエリ(郵便番号または住所)を記憶する \\ \hline
      long & total\_count & 何行データを読み込んだかを記憶する. \\ \hline
      int & hit\_index\_list[200000] & 住所検索で何行目がヒットしたかを記憶する. \\ \hline
      int & hit\_list\_count & 住所検索でヒットした回数を記憶する. \\ \hline
   \end{tabular}
\end{table}

構造型配列address\_data[200000]に郵便番号と住所のデータが入る.
データの取り出しは,address\_data[16].codeのように取り出す.
これ以降,address\_dataに指定する,配列の添字をindexと呼ぶ.

\subsection{関数の設計}
設計した各関数を表\ref{fig:func-list}に示す.
\begin{longtable}{|c|l|l|l|}
   \caption{設計した関数}
   \label{fig:func-list} \\ \hline
    関数名 & 引数 & 返り値 & 処理内容\\ \hline
    main & int , int ** & int & \begin{tabular}{l}
      コマンドラインから,\\引数を受け取り,各関数に渡す
    \end{tabular} \\ \hline
    init & 引数なし & 返り値なし & \begin{tabular}{l}
      構造体配列address\_data[2000]\\
      の初期化を行う
    \end{tabular} \\ \hline
    scan & 引数なし & 返り値なし & \begin{tabular}{l}
      住所データをCSVから読み込み,\\構造体配列に記憶させる.
    \end{tabular} \\ \hline
    run\_from\_file & const char * & 返り値なし & \begin{tabular}{l}
      コマンド、検索対象の郵便番号、\\または住所の列をテキストファイル\\から受け取り、コード検索を行う。
    \end{tabular} \\ \hline
    respond & 引数なし & 返り値なし & クエリを読み込み,応答する \\ \hline
    input & 引数なし & 返り値なし & 検索モードとクエリの入力を読み込む \\ \hline
    code\_search & 引数なし & 返り値なし & \begin{tabular}{l}
      郵便番号によって住所を検索し,\\
      検索結果を出力する
    \end{tabular} \\ \hline
    comp\_adr & \begin{tabular}{l}
      const void * ,\\
      const void *
    \end{tabular} & int & \begin{tabular}{l}
      q\_sort関数の比較関数. \\
      第1引数のindexの郵便番号が,\\
      第2引数のindexの郵便番号より\\
      大きかったら,自然数を返す.
    \end{tabular}
      \\ \hline
    binary\_search & \begin{tabular}{l}
      int , int ,\\ 
      int , \\
      ADDRESS * 
    \end{tabular}
    & 返り値なし &\begin{tabular}{l}
      第1引数に指定された値を,\\ 
      第4引数に指定された\\
      ADDRESSのindex=left から\\
      index=rightまで二分探索法で探す\\
    \end{tabular} \\ \hline
    search\_around & \begin{tabular}{l}
      int,int *,\\
      int *,\\
      ADDRESS *
    \end{tabular} & 返り値なし & \begin{tabular}{l}
      第1引数に指定された,\\
      indexの周囲を探索し,\\
      indexの郵便番号と同じ値を探す.\\
      返り値として, \\
      引数に指定されたアドレスに\\
      同じ郵便番号の始点と終点を返す
    \end{tabular} \\ \hline
    address\_search & 引数なし & 返り値なし & \begin{tabular}{l}
      クエリの住所を探索し,\\検索結果を出力する.
    \end{tabular} \\ \hline
    search & int, int * & 返り値なし & \begin{tabular}{l}
      (第1引数)行目のデータと\\
      クエリを比較し,\\
      条件に合致したら,\\第2引数の値に\\
      1を足して返す.
    \end{tabular} \\ \hline 
    comp\_code & \begin{tabular}{l}
      const void *, \\
      const void * 
    \end{tabular}
    & int & \begin{tabular}{l}
      q\_sort関数の比較関数.\\
      第1引数のindexの郵便番号が,\\
      第2引数のindexの郵便番号より\\
      大きかったら,自然数を返す.
    \end{tabular} \\ \hline
    re\_input & 引数なし & 返り値なし & \begin{tabular}{l}
      絞り込み検索をするか,ユーザーにたずねる.\\
      絞り込む場合,絞り込み検索の内容を\\queryに入れる.
    \end{tabular}\\ \hline
    refinement & 引数なし & 返り値なし & \begin{tabular}{l}
      絞り込み検索を実施し,\\検索結果を出力する
    \end{tabular} \\ \hline
\end{longtable}
関数の呼び出し関係を図\ref{fig:func-relation-main}に示す.

main関数から処理が始まり,まずinit関数で構造体の初期化が行われる.
次に,関数に引数にあるかどうかで処理が分かれる.
引数がある場合はrun\_from\_file関数が実施される.
run\_from\_file関数での呼び出し関係を図\ref{fig:func-run-from-file}に示す.
引数がない場合,respond関数が呼び出される.respond関数での呼び出し関係を図\ref{fig:func-respond}に示す.

% =============================================
% 図1: メイン処理と全体の流れ
% =============================================
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
      % ノード（箱）のデザイン定義
      func/.style={
        rectangle,
        draw=black,
        rounded corners,
        minimum width=2.5cm,
        minimum height=1cm,
        align=center,
        fill=white
      },
      % 矢印のデザイン定義
      arrow/.style={
        ->,
        >={Stealth}, % カッコいい矢印の頭
        thick
      },
      % ノード間の距離設定
      node distance=1.0cm and 1.0cm % 縦 と 横 の間隔
    ]

    % --- ノードの配置 ---
    % 基準となるメイン関数
    \node[func] (main) {メイン処理\\(main)};

    % 初期化処理 (mainから呼ばれる)
    \node[func, below=of main] (init) {初期化\\(init)};
    
    % データの読み込み (initから呼ばれる)
    \node[func, below=of init] (scan) {データ読み込み\\(scan)};

    % 実行モードの分岐 (mainから呼ばれる)
    \node[func, below left=of init, xshift=-1cm, yshift=-0.5cm] (run-file) {ファイル実行\\(run\_from\_file)};
    \node[func, below right=of init, xshift=1cm, yshift=-0.5cm] (respond) {対話モード実行\\(respond)};

    % --- 矢印をつなぐ ---
    \draw[arrow] (main) -- (init);
    \draw[arrow] (init) -- (scan);
    
    % init完了後に分岐するため、mainから矢印を引くのが論理的に正しい
    % (見やすくするため、initを経由せずmainから直接、あるいはinitの下へ分岐させる線を引きます)
    \draw[arrow] (main) to[out=210,in=90] (run-file);
    \draw[arrow] (main) to[out=330,in=90] (respond);

  \end{tikzpicture}
  \caption{全体の関数呼び出し関係図}
  \label{fig:func-relation-main}
\end{figure}

% =============================================
% 図2: run_from_file (ファイルモード) の詳細
% =============================================
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
      func/.style={
        rectangle,
        draw=black,
        rounded corners,
        minimum width=2.2cm,
        minimum height=1cm,
        align=center,
        fill=white,
        font=\small
      },
      arrow/.style={
        ->,
        >={Stealth},
        thick
      },
      node distance=1.2cm and 0.5cm
    ]

    % 親ノード
    \node[func] (from-file) {ファイルモード処理\\(run\_from\_file)};
    
    % 検索系ノード (3つの分岐)
    \node[func, below=of from-file] (ad-search) {住所から検索\\(address\_search)};
    \node[func, left=of ad-search] (code-search) {郵便番号から検索\\(code\_search)};
    \node[func, right=of ad-search] (refine) {絞り込み検索\\(refinement)};

    % 詳細処理ノード
    \node[func, below=of code-search, yshift=0.2cm] (binary) {二分探索\\(binary\_search)};
    \node[func, below=of ad-search, yshift=0.2cm] (search) {線形探索\\(search)};
    \node[func, below left=of code-search, yshift=0.2cm] (comp-adr) {qsort関数の比較関数\\(comp\_adr)};
    
    % --- 矢印 ---
    % run_from_file からの分岐
    \draw[arrow] (from-file) -- (code-search);
    \draw[arrow] (from-file) -- (ad-search);
    \draw[arrow] (from-file) -- (refine);

    % 内部処理への呼び出し
    \draw[arrow] (code-search) -- (binary);
    \draw[arrow] (ad-search) -- (search);
    \draw[arrow] (refine) |- (search); % refinementもsearchを使う
    \draw[arrow] (code-search) -- (comp-adr);

  \end{tikzpicture}
  \caption{ファイル実行モードにおける呼び出し}
  \label{fig:func-run-from-file}
\end{figure}

% =============================================
% 図3: respond (対話モード) の詳細
% =============================================
\begin{figure}[htbp]
  \centering
  \begin{tikzpicture}[
      func/.style={
        rectangle,
        draw=black,
        rounded corners,
        minimum width=2.2cm,
        minimum height=1cm,
        align=center,
        fill=white,
        font=\small
      },
      arrow/.style={
        ->,
        >={Stealth},
        thick
      },
      node distance=1.5cm and 0.5cm
    ]

    % 親ノード
    \node[func] (respond) {対話モード処理\\(respond)};

    % ユーザー入力関係
    \node[func, below left=of respond] (input) {メニュー/入力\\(input)};
    \node[func, below right=of respond] (re-input) {絞り込み入力\\(re\_input)};
    
    % 検索処理
    \node[func, below=of input] (code-search) {郵便番号検索\\(code\_search)};
    \node[func, right=of code-search] (ad-search) {住所検索\\(address\_search)};
    \node[func, below=of re-input] (refine) {絞り込み\\(refinement)};

    \node[func, below=of code-search, yshift=0.2cm] (binary) {二分探索\\(binary\_search)};
    \node[func, below=of ad-search, yshift=0.2cm] (search) {線形探索\\(search)};

    \node[func, below left=of code-search, yshift=0.2cm] (comp-adr) {qsort関数の比較関数\\(comp\_adr)};

    % --- 矢印 ---
    % respond は input を呼び出す
    \draw[arrow] (respond) -- (input);
    
    % respond は入力結果に応じて検索を呼び出す (inputが呼ぶわけではない)
    \draw[arrow] (respond) to[out=255,in=60] (code-search);
    \draw[arrow] (respond) -- (ad-search);

    % 絞り込みループの流れ
    \draw[arrow] (respond) -- (re-input);
    \draw[arrow] (respond) to[out=285,in=120] (refine);

    % 内部処理への呼び出し
    \draw[arrow] (code-search) -- (binary);
    \draw[arrow] (ad-search) -- (search);
    \draw[arrow] (refine) |- (search); % refinementもsearchを使う
    \draw[arrow] (code-search) -- (comp-adr);

  \end{tikzpicture}
  \caption{対話モード（respond）における呼び出し}
  \label{fig:func-respond}
\end{figure}

\subsection{処理の流れ・意図}
プログラムの処理は,以下の流れで実行される.
具体的なプログラムは,\ref{sec:prg-list}で示す.
()内には,「\ref{sec:explain-algo} アルゴリズムの説明」で対応する,順序番号を示す.
\\

まず,init関数が実行される.
そして,init関数からscan関数が呼び出される.
scan関数では,マクロ命令で定義されたDATEFILEからCSVファイルを読み込み,構造体配列address\_dataに読み込む.(\ref{get_csv})

その後,main関数に処理が戻り,プログラム実行時に渡された引数の数で処理が分岐する.
引数が1つ以上渡されていた場合には,run\_from\_file関数が呼び出され,そうでない場合には,respond関数が呼び出される.

run\_from\_file関数では,ファイルの検索モードに応じて,code\_search関数,address\_search関数が呼ばれる.
(\ref{req-input}, \ref{get_input},\ref{conditional_branch})

respond関数では,まず,input関数が呼び出される.
input関数では,ユーザーの望みの検索モードと検索するクエリが,変数mode,queryのそれぞれに入る.
その後、modeに応じて,code\_search関数,address\_search関数が呼ばれる.
(\ref{req-input}, \ref{get_input},\ref{conditional_branch})

code\_search関数では,まず,address\_dataの要素のポインタをstaticポインタ配列のaddress\_searchに読み込む.
新しく,ポインタ配列を作ることで,もとのaddress\_dataの情報を残しておくと同時に,この後行うクイックソートの処理を軽くしている.
クイックソートを実行した後,static変数isSortedに1を入れている.
これにより,1回目のcode\_search関数の実行が終わった後に,再度,code\_search関数が呼ばれた際に,1回目のソートされたstaticポインタ配列を再利用できるようにしている.
(\ref{1-sort})

その後,二分探索をbinary\_search関数で実行し,クエリに一致するデータがあったら,search\_around関数を実行する.
search\_around関数は,1つの郵便番号に対して複数の住所が割り当てられている場合のための関数である.
search\_around関数の実行後,結果を出力する.
(\ref{1-binary}, \ref{1-output})

address\_search関数では,読み込んだ全データを対象に,search関数を実行する.
search関数では,先に都道府県,市区町村名,町域名にクエリが含まれているかどうかを確認してる.
これは,クエリが「大阪」のように短い場合,その後のsnprintf関数による,文字列結合という重い処理を回避するためである.
(\ref{2-pref-city-town}, \ref{2-adr-all})

その後,クエリに一致したデータをクイックソートで郵便番号が昇順になるように並び替え,出力する.
(\ref{2-sort},\ref{2-output})

結果が出力された後,re\_input関数が呼ばれ,ユーザーに絞り込み検索を行いたいか,行う場合,絞り込む文字列はなにか,たずねる.文字列はqueryに入る.
(\ref{2-ask-to-refine},\ref{re_search_2s})

絞り込みをする場合,refinement関数が呼ばれる.
refinement関数では,address\_search関数で,クエリに一致したデータのみを対象にsearch関数を実行する.
search関数での処理は上述の,address\_search関数での処理と同様である.
(\ref{re_search_first},\ref{re_search_second})

search関数の実行後,クエリに一致したデータを,出力する.
address\_search関数と違い,クイックソートは行っていない.
ここでは,address\_search関数でクイックソートが実行されたデータを対象に,絞り込みを行っている.郵便番号が小さいデータから順に検索を行うため,絞り込み検索を実施した後でも,郵便番号は昇順になったままとなる.
(\ref{re_output})

その後,再び,絞り込み検索を行うか,尋ねる.
絞り込みを行う場合,上述の処理をユーザーが絞り込みをやめるまで,行う.
(\ref{re_search_2e},\ref{re_re_refine})

code\_search関数,address\_search関数での処理が終わったら,run\_from\_file関数,respond関数に処理が戻り,ファイル/ユーザーによっては再度,上述の処理を行う.
(\ref{re_do})

\section{工夫した点}
% 次回はここから
% 工夫した点を書く
% code_searchでlazy initializationを行ったこと
% static変数を用いることで,2回目以降のsortを飛ばしたこと
% 検索1で二分探索をしたこと
% 検索2で文字列結合を回避しようとする仕組みを入れたこと

検索1において,郵便番号が昇順になるように,ADDRESS型のポインタ配列をあらかじめソートしている.
このようにすることで,二分探索を行えるようにし,計算量を削減している.
また,ADDRESS型ポインタ配列の初期化やそのソートも,関数が呼ばれてから行うようにしている.
初期化やソートを遅らせることで,code\_search関数が呼ばれたときのみに,メモリを消費するようにしている.
さらに,static変数を用いることで,2回目以降のADDRESS型ポインタ配列の初期化やソートを飛ばしている.
これによって,初期化やソートといった,重い処理をなくし,時間計算量を削減している.

検索2では,先に都道府県,市区町村名,町域名にクエリが含まれているかどうかを確認してる.
これによって,snprintf関数という重い処理をできるかぎり,回避している.


\section{考察}
本プログラムは,実行速度が速い,クイックソートを使っている.
そのため,安定ではない.
これは,郵便番号1つに対し,複数の住所が割り当てられている場合は少なく,安定ソートをあまり,必要としないからである.
しかし,もしソートの安定性を求めたい場合,マージソートを使うことでメモリを消費するものの,安定性を保つことができる.

本プログラムは動作はするものの,時間計算量や空間計算量という観点での改善部分は多くある.

特に,構造体のデータ型については,工夫の余地がある.
prefについては,都道府県の名前が入った,文字列の配列を別で用意し,CSVのデータをもとに,その配列に対するポインタを構造体にいれるようにすれば,メモリを削減できる.
具体的には,char pref[20]から,char *prefに変更することで,
構造体1つあたり,5 byte削減できるので,200000の構造体配列全体では,1MBの削減となる.

また,構造体の要素数についても,200000ではなく,今回用いたCSVファイルの全行数である,124340とすることで,さらに,メモリを削減できる.
ただし,この場合,もとのCSVファイルのデータが変わったとき,意図しない動作が起こりうる.
そのため,CSVファイルのデータが変わることはないというのが前提である.



\section{感想}
つまらないミスで,かなりの時間をプログラム作成に費やすこととなってしまった.
プログラム作成で,仕様や指示を厳守するように気をつけたい.

また,ファイルに直接,文字列型変数に日本語を書き込んで,実装すると,動作確認が通らなかった.未だに,原因がわかっていないのが悔しい.

\section{作業工程}

\begin{table}[htbp]
   \centering
   \caption{作業工程}
   \label{fig:work-process}
   \begin{tabular}{|c|l|} \hline
      作業内容 & 要した時間\\ \hline
      アルゴリズム設計 & 5時間 \\ \hline
      プログラム設計 & 3時間 \\ \hline
      コーディング & 20時間 \\ \hline
      デバッグ & 30時間 \\ \hline
      レポート作成 & 15時間 \\ \hline
   \end{tabular}
\end{table}

\appendix
\section{プログラムリスト}
\label{sec:prg-list}

作成したプログラムをListing \ref{prg:first} - Listing \ref{prg:end}に示す.

\lstset{
  basicstyle={\ttfamily\small},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  % frame={tb},
  breaklines=true,
  breakatwhitespace=false,  % 空白以外でも折り返す（重要）
  columns=flexible,         % 文字幅を固定せず、自然な詰まり方にする（重要）
  postbreak=\mbox{\textcolor{gray}{$\hookrightarrow$}\space}, % 折り返し行の先頭に矢印を表示
  % columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}

\begin{lstlisting}[caption={マクロ命令と大域変数の定義}, label={prg:first}]
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#ifndef __linux__
#include <windows.h>
#endif

#define ADVANCED 1 // 発展課題（絞り込み検索）に対応する場合は1に変更

#define CLEN 9   // 郵便番号の最大バイト長
#define ALEN 200 // 住所欄の最大バイト長
#define DATAFILE "data_utf.csv"
#define MAX_SIZE 200000 // 住所録中の住所数の最大数

// 動作確認で使うファイル実行モードで使う定数。修正不要
#define STANDBY_MAIN 0
#define QUERY_POSTAL 1
#define QUERY_ADDRESS 2
#define STANDBY_REFINE 3
#define QUERY_REFINE 4

int mode;         // 検索モード 0:なし，1:郵便番号検索，2:文字列検索
int refine_flag;  // 絞り込み検索の有無 0:なし，1:あり
char query[ALEN]; // 検索クエリ（郵便番号or文字列）
typedef struct address
{
  int code;       // 郵便番号
  char pref[20];     // char pref[13]; //都道府県 MAX 4 x 3
  char city[32];  // 市町村 MAX 10 x 3
  char town[116]; // 町域 MAX 38 x 3
} ADDRESS;        // データ記録用構造体
ADDRESS address_data[MAX_SIZE];
long total_count = 0;
\end{lstlisting}

\begin{lstlisting}[caption={scan関数}]
// 住所データファイルを読み取り，配列に保存
void scan()
{
  FILE *fp;
  long line = 0;
  char code[CLEN + 1], pref[ALEN + 1], city[ALEN + 1], town[ALEN + 1]; // tmp[ALEN+1];

  // datasizeの計算
  if ((fp = fopen(DATAFILE, "r")) == NULL)
  {
    fprintf(stderr, "error:cannot read %s\n", DATAFILE);
    exit(-1);
  }
  while(fscanf(fp, "%*[^,],%*[^,],\"%[^\"]\",%*[^,],%*[^,],%*[^,],\"%[^\"]\",\"%[^\"]\",\"%[^\"]\",%*s",code,pref,city,town) != EOF )
  {
    {
      /*
        上のfscanfにより，code,pref,city,townにそれぞれ郵便番号，都道府県，市町村，町域を表す
        文字列が記憶される．この箇所にコードを加筆し，
  　　　これらの情報を用いて構造体の配列に住所データを記憶させる．
       */
      address_data[line].code = atoi(code);
      strcpy(address_data[line].pref, pref);
      // jis_code = atoi(jis)/1000;
      // address_data[line].pref = pref_names[jis_code - 1];
      strcpy(address_data[line].city, city);
      strcpy(address_data[line].town, town);
      line++;
    }
    total_count = line;
  }
  fclose(fp);
}
\end{lstlisting}

\begin{lstlisting}[caption={code\_search関数と呼び出される関数}]
int binary_search(int search_code, int left, int right, ADDRESS *address_index[])
{
  int half;
  while (left <= right)
  {
    half = (left + right) / 2;
    if (search_code < address_index[half]->code)
    {
      right = half - 1;
    }
    if (search_code > address_index[half]->code)
    {
      left = half + 1;
    }
    if (search_code == address_index[half]->code)
    {
      return half;
    }
  }
  return -1;
}

void search_around(int index, int *left, int *right, ADDRESS *address_index[])
{
  *left = index;
  if (index > 0)
  {
    while (address_index[*left - 1]->code == address_index[index]->code)
      (*left)--;
  }
  *right = index;
  if (index < total_count - 1)
  {
    while (address_index[*right + 1]->code == address_index[index]->code)
      (*right)++;
  }
}

// comp for qsort()
int comp_adr(const void *vxp, const void *vyp)
{
  ADDRESS *xp = *(ADDRESS **)vxp;
  ADDRESS *yp = *(ADDRESS **)vyp;
  return xp->code - yp->code;
}

// 郵便番号による住所検索．検索結果を出力．
void code_search()
{
  if (query[0] == '\0' || query[0] == '\n')
  {
    return;
  }
  static int isSorted = 0;
  static ADDRESS *address_search[MAX_SIZE];
  if (!(isSorted))
  {
    for (int i = 0; i < total_count; i++)
    {
      address_search[i] = &address_data[i];
    }
    qsort(address_search, total_count, sizeof(ADDRESS *), comp_adr);
    isSorted = 1;
  }
  int search_code = atoi(query);
  int result = binary_search(search_code, 0, total_count - 1, address_search);
  if (result != -1)
  {
    int left, right;
    search_around(result, &left, &right, address_search);
    for (int i = left; i <= right; i++)
    {
      printf("%07d:%s%s%s\n", address_search[i]->code, address_search[i]->pref, address_search[i]->city, address_search[i]->town);
    }
  }
  return;
}
\end{lstlisting}

\begin{lstlisting}[caption={address\_search関数と呼び出される関数}]
int comp_code(const void *a, const void *b)
{
  // printf("%d\n", *(int *)a);
  return address_data[*(int *)a].code - address_data[*(int *)b].code;
}


// 文字列による住所検索．検索結果を出力．
int hit_index_list[MAX_SIZE];
int hit_list_count;

void search(int index, int *hit_list_count){
  int isHit = 0;

  if (strstr(address_data[index].pref, query) != NULL)
  {
    isHit = 1;
  }
  else if (strstr(address_data[index].city, query) != NULL)
  {
    isHit = 1;
  }
  else if (strstr(address_data[index].town, query) != NULL)
  {
    isHit = 1;
  }
  else
  {
    char address_line[300];
    snprintf(address_line,
              sizeof(address_line),
              "%s%s%s",
              address_data[index].pref,
              address_data[index].city,
              address_data[index].town);
    if (strstr(address_line, query) != NULL)
    {
      isHit = 1;
    }
  }

  if (isHit)
  {
    hit_index_list[*hit_list_count] = index;
    (*hit_list_count)++;
  }
}

void address_search()
{
  hit_list_count = 0;
  if (query[0] == '\0' || query[0] == '\n') return;
  // int pref_index = -1;
  // for (int i = 0; i < 47; i++)
  // {
  //   if (strstr(query, pref_names[i]) != NULL)
  //   {
  //     pref_index = i;
  //     break;
  //   }
  // }
  for (int line=0; line < total_count; line++){
    search(line, &hit_list_count);
  }
  qsort(hit_index_list, hit_list_count, sizeof(int), comp_code);
  for (int i = 0; i < hit_list_count; i++)
  {
    printf("%07d:%s%s%s\n", address_data[hit_index_list[i]].code, address_data[hit_index_list[i]].pref, address_data[hit_index_list[i]].city, address_data[hit_index_list[i]].town);
  }
  // printf("%d\n", hit_list_index);
  return;
}
\end{lstlisting}

\begin{lstlisting}[caption={refinement関数}]
// 絞り込み検索の実施
void refinement()
{
  int re_hit_list_count = 0;
  if (query[0] == '\0' || query[0] == '\n')
    return;
  for (int line = 0; line < hit_list_count; line++)
  {
    search(hit_index_list[line], &re_hit_list_count);
  }
  hit_list_count = re_hit_list_count;
  for (int i = 0; i < hit_list_count; i++)
  {
    printf("%07d:%s%s%s\n", address_data[hit_index_list[i]].code, address_data[hit_index_list[i]].pref, address_data[hit_index_list[i]].city, address_data[hit_index_list[i]].town);
  }
  return;
}
\end{lstlisting}

\begin{lstlisting}[caption={input関数とre\_input関数}, label={prg:end}]
void input()
{
  printf("\n"
         "#########Top Menu#########\n"
         "# Search by postal code: 1\n"
         "# Search by address    : 2\n"
         "# Exit                 : 0\n"
         "> ");

  scanf("%d", &mode);
  if (mode == 1)
  {
    printf("Postal code > ");
    scanf("%s", query);
  }
  else if (mode == 2)
  {
    printf("Search String > ");
    scanf("%s", query);
  }
}

// 絞り込み検索の有無を確認
void re_input()
{
  printf("\n"
         "# Continue Searching: 1\n"
         "# Return to Top Menu: 0\n"
         "> ");
  scanf("%d", &refine_flag);
  if (refine_flag == 1)
  {
    printf("String for Refinement> ");
    scanf("%s", query);
  }
}
\end{lstlisting}

\end{document}

